package csharp

import (
	"bytes"
	"strings"
	"text/template"

	"github.com/glynternet/osc-proto/pkg/generate"
	"github.com/glynternet/osc-proto/pkg/types"
	"github.com/pkg/errors"
)

var fileTmpl = func() *template.Template {
	const tmplStr = `using System;
using System.Collections.Generic;
using avvaunity.GOH.Unity.Message.Unmarshaller;

namespace {{.Namespace}} {

    // Code generated by osc-proto (version {{.OSCProtoVersion}}) DO NOT EDIT.
{{template "types" .Types}}}
`
	t, err := template.New("csharp").Parse(tmplStr)
	if err != nil {
		panic(errors.Wrap(err, "parsing template"))
	}

	t, err = t.Parse(`
{{define "types"}}{{range .}}
    public readonly struct {{.TypeName}} {
{{range .Fields}}        private readonly {{.FieldType}} _{{.FieldName}};
{{end}}
        public {{.TypeName}}({{.ConstructorParameters}}) {
{{range .Fields}}            _{{.FieldName}} = {{.FieldName}};
{{end}}        }
{{range .Fields}}
        public {{.FieldType}} {{.FieldNameGetter}}() {
            return _{{.FieldName}};
        }
{{end}}    }

    public class {{.TypeName}}Unmarshaller : IMessageUnmarshaller<{{.TypeName}}> {

{{range .Fields}}        // <{{.FieldName}}:{{.OriginalFieldType}}>
{{end}}        public {{.TypeName}} Unmarshal(List<object> data) {
            if (data.Count != {{len .Fields}}) {
                throw new ArgumentException($"Expected {{len .Fields}} item in arg list but got {data.Count}");
            }
{{range $i, $field := .Fields}}            var {{.FieldName}} = {{.FieldTypeParseFunc}}(data[{{$i}}].ToString());
{{end}}            return new {{.TypeName}}({{.UnmarshalledConstructorCallArgs}});
        }

        private static bool ParseBool(string value) {
            try {
                return int.Parse(value) != 0;
            }
            catch (Exception e) {
                throw new ArgumentException($"cannot parse {value} to bool", e);
            }
        }
    }
{{end}}{{end}}
`)
	if err != nil {
		panic(errors.Wrap(err, "parsing types template"))
	}
	return t
}()

type Generator struct {
	OSCProtoVersion string
	Namespace       string
}

type fieldTemplateVars struct {
	FieldName          types.FieldName
	FieldNameGetter    string
	OriginalFieldType  types.FieldType
	FieldType          string
	FieldTypeParseFunc string
}

type typeTemplateVars struct {
	TypeName                        types.TypeName
	ConstructorParameters           string
	UnmarshalledConstructorCallArgs string
	Fields                          []fieldTemplateVars
}

func (g Generator) Generate(definitions generate.Definitions) (map[string][]byte, error) {
	if len(definitions.Types) == 0 {
		return nil, nil
	}
	ttvs, err := generateTypeTemplateVars(definitions, typeConversions())
	if err != nil {
		return nil, errors.Wrap(err, "generating typeTemplateVars")
	}
	version := strings.TrimSpace(g.OSCProtoVersion)
	if version == "" {
		version = "unknown"
	}
	var out bytes.Buffer
	if err := fileTmpl.Execute(&out, struct {
		OSCProtoVersion string
		Namespace       string
		Types           []typeTemplateVars
	}{
		OSCProtoVersion: version,
		Namespace:       g.Namespace,
		Types:           ttvs,
	}); err != nil {
		return nil, errors.Wrap(err, "executing template")
	}
	return map[string][]byte{
		g.Namespace + ".cs": out.Bytes(),
	}, nil
}

func generateTypeTemplateVars(definitions generate.Definitions, typeConversions map[types.FieldType]typeConversion) ([]typeTemplateVars, error) {
	var ttvs []typeTemplateVars
	for _, name := range definitions.Types.SortedNames() {
		var ftvs []fieldTemplateVars
		typeName := types.TypeName(name)
		fields := definitions.Types[typeName]
		for _, field := range fields {
			conversions, ok := typeConversions[field.FieldType]
			if !ok {
				return nil, types.TypeError{
					TypeName: typeName,
					Err: types.UnsupportedFieldType{
						FieldType: field.FieldType,
						FieldName: field.FieldName,
					},
				}
			}
			ftvs = append(ftvs, fieldTemplateVars{
				FieldName:          field.FieldName,
				FieldNameGetter:    strings.Title(string(field.FieldName)),
				OriginalFieldType:  field.FieldType,
				FieldType:          conversions.ttype,
				FieldTypeParseFunc: conversions.parseDataFieldFunc,
			})
		}

		ttvs = append(ttvs, typeTemplateVars{
			TypeName:                        types.TypeName(strings.Title(name)),
			ConstructorParameters:           constructorParameters(typeConversions, fields),
			UnmarshalledConstructorCallArgs: unmarshalledConstructorCallArgs(fields),
			Fields:                          ftvs,
		})
	}
	return ttvs, nil
}

func constructorParameters(conversions map[types.FieldType]typeConversion, fields types.TypeFields) string {
	var params []string
	for _, field := range fields {
		params = append(params, conversions[field.FieldType].ttype+" "+string(field.FieldName))
	}
	return strings.Join(params, ", ")
}

func unmarshalledConstructorCallArgs(fields types.TypeFields) string {
	var args []string
	for _, field := range fields {
		args = append(args, string(field.FieldName))
	}
	return strings.Join(args, ", ")
}

type typeConversion struct {
	ttype              string
	parseDataFieldFunc string
}

func typeConversions() map[types.FieldType]typeConversion {
	return map[types.FieldType]typeConversion{
		"bool": {
			ttype:              "bool",
			parseDataFieldFunc: "ParseBool",
		},
		"int32": {
			ttype:              "int",
			parseDataFieldFunc: "int.Parse",
		},
	}
}
