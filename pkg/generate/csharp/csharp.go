package csharp

import (
	"bytes"
	"strings"
	"text/template"

	"github.com/glynternet/osc-proto/pkg/types"
	"github.com/pkg/errors"
)

var tmpl = func() *template.Template {
	const tmplStr = `using System;
using System.Collections.Generic;
using avvaunity.GOH.Unity.Message.Unmarshaller;

namespace {{.Namespace}} {

    // Code generated by osc-proto (version {{.OSCProtoVersion}}) DO NOT EDIT.
{{range .Types}}
    public readonly struct {{.TypeName}} {
{{range .Fields}}        private readonly {{.FieldType}} _{{.FieldName}};
{{end}}
        public {{.TypeName}}({{.ConstructorParameters}}) {
{{range .Fields}}            _{{.FieldName}} = {{.FieldName}};
{{end}}        }
{{range .Fields}}
        public {{.FieldType}} {{.FieldNameGetter}}() {
            return _{{.FieldName}};
        }
{{end}}    }

    public class {{.TypeName}}Unmarshaller : IMessageUnmarshaller<{{.TypeName}}> {

{{range .Fields}}        // <{{.FieldName}}:{{.OriginalFieldType}}>
{{end}}        public {{.TypeName}} Unmarshal(List<object> data) {
            if (data.Count != {{len .Fields}}) {
                throw new ArgumentException($"Expected {{len .Fields}} item in arg list but got {data.Count}");
            }
{{range $i, $field := .Fields}}            var {{.FieldName}} = {{.FieldTypeParseFunc}}(data[{{$i}}].ToString());
{{end}}            return new {{.TypeName}}({{.UnmarshalledConstructorCallArgs}});
        }

        private static bool ParseBool(string value) {
            try {
                return int.Parse(value) != 0;
            }
            catch (Exception e) {
                throw new ArgumentException($"cannot parse {value} to bool", e);
            }
        }
    }
{{end}}}
`
	t, err := template.New("csharp").Parse(tmplStr)
	if err != nil {
		panic(errors.Wrap(err, "parsing template"))
	}
	return t
}()

type Generator struct {
	OSCProtoVersion string
	Namespace       string
}

func (g Generator) Generate(typesToGenerate types.Types) (map[string][]byte, error) {
	if len(typesToGenerate) == 0 {
		return nil, nil
	}

	type fieldTemplateVars struct {
		FieldName          types.FieldName
		FieldNameGetter    string
		OriginalFieldType  types.FieldType
		FieldType          string
		FieldTypeParseFunc string
	}

	type typeTemplateVars struct {
		TypeName                        types.TypeName
		ConstructorParameters           string
		UnmarshalledConstructorCallArgs string
		Fields                          []fieldTemplateVars
	}

	convertedFieldTypes := convertedFieldTypes()
	parseDataFieldFuncs := parseDataFieldFuncs()
	var ttvs []typeTemplateVars
	for _, name := range typesToGenerate.SortedNames() {
		var ftvs []fieldTemplateVars
		typeName := types.TypeName(name)
		fields := typesToGenerate[typeName]
		for _, field := range fields {
			convertedType, ok := convertedFieldTypes[field.FieldType]
			if !ok {
				return nil, types.TypeError{
					TypeName: typeName,
					Err: types.UnsupportedFieldType{
						FieldType: field.FieldType,
						FieldName: field.FieldName,
					},
				}
			}
			parseFieldFunc, ok := parseDataFieldFuncs[field.FieldType]
			if !ok {
				return nil, types.TypeError{
					TypeName: typeName,
					Err: types.UnsupportedFieldType{
						FieldType: field.FieldType,
						FieldName: field.FieldName,
					},
				}
			}
			ftvs = append(ftvs, fieldTemplateVars{
				FieldName:          field.FieldName,
				FieldNameGetter:    strings.Title(string(field.FieldName)),
				OriginalFieldType:  field.FieldType,
				FieldType:          convertedType,
				FieldTypeParseFunc: parseFieldFunc,
			})
		}

		ttvs = append(ttvs, typeTemplateVars{
			TypeName:                        types.TypeName(strings.Title(name)),
			ConstructorParameters:           constructorParameters(convertedFieldTypes, fields),
			UnmarshalledConstructorCallArgs: unmarshalledConstructorCallArgs(fields),
			Fields:                          ftvs,
		})

	}
	version := strings.TrimSpace(g.OSCProtoVersion)
	if version == "" {
		version = "unknown"
	}
	var out bytes.Buffer
	if err := tmpl.Execute(&out, struct {
		OSCProtoVersion string
		Namespace       string
		Types           []typeTemplateVars
	}{
		OSCProtoVersion: version,
		Namespace:       g.Namespace,
		Types:           ttvs,
	}); err != nil {
		return nil, errors.Wrap(err, "executing template")
	}
	return map[string][]byte{
		g.Namespace + ".cs": out.Bytes(),
	}, nil
}

func constructorParameters(convertedFieldTypes map[types.FieldType]string, fields types.TypeFields) string {
	var params []string
	for _, field := range fields {
		params = append(params, convertedFieldTypes[field.FieldType]+" "+string(field.FieldName))
	}
	return strings.Join(params, ", ")
}

func unmarshalledConstructorCallArgs(fields types.TypeFields) string {
	var args []string
	for _, field := range fields {
		args = append(args, string(field.FieldName))
	}
	return strings.Join(args, ", ")
}

func convertedFieldTypes() map[types.FieldType]string {
	return map[types.FieldType]string{
		"bool":  "bool",
		"int32": "int",
	}
}

func parseDataFieldFuncs() map[types.FieldType]string {
	return map[types.FieldType]string{
		"bool":  "ParseBool",
		"int32": "int.Parse",
	}
}
