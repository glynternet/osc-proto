package golang

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/glynternet/osc-proto/pkg/generate"
	"github.com/glynternet/osc-proto/pkg/routers"
	"github.com/glynternet/osc-proto/pkg/types"
	"github.com/pkg/errors"
)

var tmpl = func() *template.Template {
	const tmplStr = `package {{.Package}}{{if .RouteMessages}}

import "github.com/hypebeast/go-osc/osc"{{end}}

// Code generated by osc-proto (version {{.OSCProtoVersion}}) DO NOT EDIT.
{{range .Types}}
func {{.MessageArgsConstructorFuncName}}({{.MessageArgsFunctionParameters}}) []interface{} {
	return []interface{}{{"{"}}{{.InterfaceSliceElements}}{{"}"}}
}
{{end}}{{range .RouteMessages}}
func {{.ID}}({{.MessageArgsFunctionParameters}}) osc.Message {
	return osc.Message{
		Address:   "{{.OSCAddress}}",
		Arguments: append([]interface{}{{"{"}}"{{.Name}}"{{"}"}}, {{.MessageArgsConstructorFuncName}}({{.MessageArgsConstructorCallArgs}})...),
	}
}
{{end}}
// boolInt32 returns an int32 representation of a bool.
// This is required for supporting OSC frameworks that
// don't support a boolean primitive
func boolInt32(value bool) int32 {
	if value {
		return 1
	}
	return 0
}
`
	t, err := template.New("golang").Parse(tmplStr)
	if err != nil {
		panic(errors.Wrap(err, "parsing template"))
	}
	return t
}()

type Generator struct {
	OSCProtoVersion string
	Package         string
}

func (g Generator) Generate(definitions generate.Definitions) (map[string][]byte, error) {
	if len(definitions.Types) == 0 {
		return nil, nil
	}

	typeTmplVarss, err := generateTypeTmplVars(definitions)
	if err != nil {
		return nil, errors.Wrap(err, "generating typeTmplVars")
	}
	routeTmplVarss, err := generateRouteTmplVars(definitions)
	if err != nil {
		return nil, errors.Wrap(err, "generating route messages")
	}

	var out bytes.Buffer
	version := strings.TrimSpace(g.OSCProtoVersion)
	if version == "" {
		version = "unknown"
	}
	if err := tmpl.Execute(&out, struct {
		OSCProtoVersion string
		Package         string
		Types           []typeTmplVars
		RouteMessages   []routeTmplVars
	}{
		OSCProtoVersion: version,
		Package:         g.Package,
		Types:           typeTmplVarss,
		RouteMessages:   routeTmplVarss,
	}); err != nil {
		return nil, errors.Wrap(err, "executing template")
	}

	return map[string][]byte{g.Package + ".go": out.Bytes()}, nil
}

type typeTmplVars struct {
	MessageArgsConstructorFuncName string
	MessageArgsFunctionParameters  string
	InterfaceSliceElements         string
}

type routeTmplVars struct {
	ID                             string
	Name                           string
	OSCAddress                     string
	MessageArgsFunctionParameters  string
	MessageArgsConstructorFuncName string
	MessageArgsConstructorCallArgs string
}

func generateTypeTmplVars(definitions generate.Definitions) ([]typeTmplVars, error) {
	var typeTmplVarss []typeTmplVars
	for _, name := range definitions.Types.SortedNames() {
		typeName := types.TypeName(name)
		fields := definitions.Types[typeName]
		sliceElements, err := interfaceSliceElements(fields)
		if err != nil {
			return nil, errors.Wrapf(err, "generating interface slice elements for type:%s", name)
		}
		typeTmplVarss = append(typeTmplVarss, typeTmplVars{
			MessageArgsConstructorFuncName: messageArgsConstructorFuncName(typeName),
			MessageArgsFunctionParameters:  messageArgsFunctionParameters(fields),
			InterfaceSliceElements:         sliceElements,
		})
	}
	return typeTmplVarss, nil
}

func generateRouteTmplVars(definitions generate.Definitions) ([]routeTmplVars, error) {
	if len(definitions.Routers) == 0 {
		return nil, nil
	}
	var rms []routeTmplVars
	for _, name := range definitions.Routers.SortedNames() {
		routerName := routers.RouterName(name)
		routes := definitions.Routers[routerName]
		for _, routeName := range routes.SortedNames() {
			argTypeName := routes[routers.RouteName(routeName)]
			argFields, ok := definitions.Types[argTypeName]
			if !ok {
				return nil, fmt.Errorf("cannot find fields for type:%s in router:%s route:%s", argTypeName, routerName, routeName)
			}
			rms = append(rms, routeTmplVars{
				ID:                             strings.Title(string(routerName)) + strings.Title(routeName),
				Name:                           routeName,
				OSCAddress:                     "/" + string(routerName),
				MessageArgsFunctionParameters:  messageArgsFunctionParameters(argFields),
				MessageArgsConstructorFuncName: messageArgsConstructorFuncName(argTypeName),
				MessageArgsConstructorCallArgs: messageArgsConstructorCallArgs(argFields),
			})
		}
	}
	return rms, nil
}

func messageArgsConstructorFuncName(name types.TypeName) string {
	return strings.Title(string(name)) + "MessageArgs"
}

func messageArgsFunctionParameters(fields types.TypeFields) string {
	var params []string
	for _, field := range fields {
		params = append(params, string(field.FieldName)+" "+string(field.FieldType))
	}
	return strings.Join(params, ", ")
}

func messageArgsConstructorCallArgs(fields types.TypeFields) string {
	var params []string
	for _, field := range fields {
		params = append(params, string(field.FieldName))
	}
	return strings.Join(params, ", ")
}

func fieldArgFuncs() map[types.FieldType]func(string) string {
	return map[types.FieldType]func(string) string{
		// TODO(glynternet): upgrade to support receiving bools in UnityOSC
		//   so we don't have to do this as a boolInt32
		"bool":    func(argName string) string { return fmt.Sprintf("boolInt32(%s)", argName) },
		"float32": func(argName string) string { return argName },
		"int32":   func(argName string) string { return argName },
		"string":  func(argName string) string { return argName },
	}
}

func interfaceSliceElements(fields types.TypeFields) (string, error) {
	if len(fields) == 0 {
		return "", nil
	}
	var args []string
	fieldArgFuncs := fieldArgFuncs()
	for _, field := range fields {
		arg, ok := fieldArgFuncs[field.FieldType]
		if !ok {
			return "", types.UnsupportedFieldType{
				FieldType: field.FieldType,
				FieldName: field.FieldName,
			}
		}
		args = append(args, arg(string(field.FieldName))+",")
	}
	return "\n\t\t" + strings.Join(args, "\n\t\t") + "\n\t", nil
}
